<template>
  <div>
    <header>
      <h1>
          De Pizzeria is
          <span class="card" v-if="open == null">...</span>
          <span class="card open" v-else-if="open == true">Open!</span>
          <span class="card closed" v-else-if="open == false">Gesloten</span>
      </h1>
      <!-- MetaMask -->
      <div v-if="open != null">
        <div>
          <img height="50" :src="require('../assets/metamask.svg')" />
          <br />
          <div v-if="account">{{account[0].substring(0,11) + "..."}}</div>
          <button v-else @click="connectToMetaMask()">MetaMask Login</button>
        </div>
      </div>
    </header>

    <div class="content">
      <p>De website roept de functie 'getOpen()' aan in de 'PizzaContract' Smart Contract.</p>
      <div v-if="open != null">
        <button :disabled="!account" @click="togglePizzeria()">{{open ? "Sluit Pizzeria" : "Open Pizzeria"}}</button>
        <p>Deze knop zal de 'setOpen()' Smart Contract functie aanroepen. <br/> Omdat 'setOpen()' een aanpassing is aan de inhoud van de Smart Contract, moeten de Gas fees worden betaald door het account dat het aanroept.</p>
      </div>
      <hr />
      <!-- Pizza lijst -->
      <div class="pizzaInventory">
        <div v-for="pizza in pizzas" :key="pizza.name">
          <img :src="tryToGetPizzaPicture(pizza.name)" alt="🍕" />
          <h3>Pizza {{pizza.name}}</h3>
          <button :disabled="open == null" @click="buyPizza(pizza.name)">Bestel Pizza {{pizza.name}}<br />({{pizzaCost}} ETH)</button>
          <p v-if="contract" class="owner">{{pizza.owner}}</p>
          <!-- TODO: Bought by -->
        </div>
      </div>
      <p v-if="error" class="error">Je kan geen pizza kopen: '{{error}}'</p>
    </div>
  </div>
</template>

<script>
import { markRaw } from '@vue/reactivity';

export default {
  inject: ["ethers", "address", "abi"],
  data()
  {
    return {
      blockchainUrl: "http://127.0.0.1:7545",
      contract: null,
      open: null,
      account: null,
      error: null,

      pizzas: [
        { name:"Pepperoni" },
        { name:"Tonno" },
        { name:"Veggie" },
      ],
      pizzaCost: "0.7",
    }
  },
  mounted(){
    //This provider directly communicates with the blockchain on the url.
    var provider = new this.ethers.providers.JsonRpcProvider(this.blockchainUrl); 
    this.createContract(provider);

    this.getOwners();

    this.load();
  },
  methods: {
    async load()
    {
      //Example of reading from a Blockchain:
      this.open = await this.contract.getOpen();
    },
    async createContract(providerOrSigner)
    {
      //A provider provides read access to a Smart Contract.
      //A signer can call both read and write functions to a Smart Contract.
      this.contract = markRaw(new this.ethers.Contract(this.address, this.abi, providerOrSigner));
    },
    async togglePizzeria()
    {
      var res = await this.contract.setOpen(!this.open);
      await this.contract.provider.waitForTransaction(res['hash']);//This simply waits for the transaction to complete.
      this.open = await this.contract.getOpen();//When the transaction is complete, ask the Smart Contract for the new state.
    },
    async buyPizza(name)
    {
      this.error = null;
      try {
        //When we send an object with the value field {value:x} to a Smart Contract function, we can send some crypto over to the contract.
        var res = await this.contract.buyPizza(name, {value: this.ethers.utils.parseEther(this.pizzaCost)});
        await this.contract.provider.waitForTransaction(res['hash']);
      } catch (e) {
        console.error(e);
        this.error = this.convertToError(e);
      }
    },
    async connectToMetaMask()
    {
      const { ethereum } = window;

      try {
        if(this.account == null)
          this.account = await ethereum.request({method: "eth_requestAccounts"});
      } catch (error) {
        return;
      }

      //Because the website is now connected to MetaMask, a Wallet.
      //We want to update the contract by replacing the provider with a signer.
      // (The MetaMask wallet will become the signer)
      //This allows us to use the full Smart Contract's functionalities, like modifications and sending transactions.
      const metamaskProvider = new this.ethers.providers.Web3Provider(ethereum);
      const signer = metamaskProvider.getSigner();
      this.createContract(signer);
    },
    async getOwners()
    {
      for (let i = 0; i < this.pizzas.length; i++) {
        try {
          console.log(this.pizzas[i].name);
          var val = await this.contract.getPizzaBuyer(this.pizzas[i].name);
          this.pizzas[i].owner = val;
        } catch (error) {
          console.log('e')
        }
      }

      this.pizzas = [...this.pizzas];
    },
    tryToGetPizzaPicture(pizza)
    {
      try {
        return require('../assets/pizzas/'+pizza+'.png');
      } catch (error) {
        return "";
      }
    },
    convertToError(e)
    {
      if(e.data)
      {
        return e.data['message'].split(': revert')[1];
      }
      else
      {
        return e.toString().substring(7).split(" (")[0];
      }
    }
  }
}
</script>

<style scoped>
header {
  display: grid;
  grid-template-columns: 4fr 1fr;
  background: yellowgreen;
}

.card {
  background-color: lightslategray;
  color: whitesmoke;
  padding: 10px;
  border-radius: 20px;
}
.open {
  background-color: green;
}
.closed {
  background-color: darkred;
}

.content {
  max-width: 600px;
  margin: auto auto;
  padding: 10px;
}

.error {
  color: darkred;
  font-weight: bold;
  text-decoration: underline;
}

.owner {
  color: green;
  font-weight: bold;
  text-decoration: underline;
}

.pizzaInventory {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
}
.pizzaInventory div {
  padding: 10px;
}
.pizzaInventory img {
  max-width: 90%;
}
</style>